`include "discipline.vams"
`include "constants.vams"

//==============================================================
// Verilog-AMS SAR ADC Behavioral Model
// Includes:
//  - Capacitor mismatch (per bit)
//  - Comparator offset
//  - Sample & Hold
//  - SAR algorithm behavior
//
//  Author: ChatGPT AMS Modeling Expert
//==============================================================

module sar_adc #(
    parameter integer N = 10,                 // ADC resolution
    parameter real vrefp = 1.0,               // Positive reference
    parameter real vrefn = 0.0,               // Negative reference
    parameter real comp_offset = 1e-3,        // Comparator offset [V]
    parameter real mismatch_sigma = 0.002     // CDAC mismatch std-dev
)(
    input electrical vin,                     // Analog input
    input logic clk,                          // SAR clock
    output logic [N-1:0] dout                 // Digital output
);

    //-------------
    // Internal variables
    //-------------
    real sample_value;                         // sampled input
    real cdac_value;                           // DAC output
    real weight[N:0];                           // ideal CDAC weights
    real weight_mis[N:0];                       // mismatched weights
    integer bit_ptr;                            // current bit index
    logic [N-1:0] sar_reg;                     // SAR register

    //-------------
    // Generate CDAC capacitor mismatches
    //-------------
    analog initial begin : init_mismatch
        integer i;
        for (i = 0; i < N; i=i+1) begin
            weight[i] = (vrefp - vrefn) / (2.0 ** (i+1));    // ideal weight
            weight_mis[i] = weight[i] * (1.0 + $rdist_normal(0, mismatch_sigma));
        end
    end

    //-------------
    // Sample-and-hold on rising edge of clk
    //-------------
    always @(posedge clk) begin
        sample_value = V(vin);       // sample the input
        bit_ptr = N-1;               // start from MSB
        sar_reg = '0;                // clear SAR register
    end

    //-------------
    // SAR bit-cycling
    //-------------
    always @(negedge clk) begin
        if (bit_ptr >= 0) begin
            real dac_val = compute_dac(sar_reg, bit_ptr);
            real comp_in = sample_value - dac_val;

            // comparator decision including offset
            if (comp_in >= comp_offset)
                sar_reg[bit_ptr] = 1'b1;
            else
                sar_reg[bit_ptr] = 1'b0;

            bit_ptr = bit_ptr - 1;
        end
    end

    //-------------
    // Drive output
    //-------------
    always @(posedge clk) begin
        if (bit_ptr < 0)
            dout <= sar_reg;
    end


    //==============================================================
    // FUNCTION: compute_dac
    //  Computes CDAC output using mismatched weights
    //==============================================================
    function real compute_dac(
        input logic [N-1:0] reg_bits,
        input integer trial_bit
    );
        real sum;
        integer i;
        begin
            // Temporarily assume trial-bit = '1'
            logic [N-1:0] reg_temp = reg_bits;
            reg_temp[trial_bit] = 1'b1;

            sum = 0.0;
            for (i = 0; i < N; i=i+1) begin
                if (reg_temp[i] == 1'b1)
                    sum = sum + weight_mis[i];
            end

            compute_dac = vrefn + sum;
        end
    endfunction

endmodule
